#!/usr/bin/env python
"""
Simulate the Goldstone Solar System Radar (GSSR)
generating simulated baseband of signals transmitted by GSSR.

As of 2019 GSSR supported three broad modes:
- Continuous Wave (CW):
    "Initial characterization of an asteroid is typically done with CW transmission,
    at 8560 MHz, usually with an offset of 500 Hz to displace it from the zero-frequency
    when the received signal is down-converted to complex baseband. Often a second offset
    is also applied, of no more than a few kHz, to pre-compensate for Doppler shifts
    from motion of the target object, and motion of the antenna as the Earth rotates."
- Binary Phase Coding (BPC), similar to BPSK:
    - "The transmitter operates at 8560 MHz, usually with an offset of some tens of Hz,
    as well as a Doppler correction offset. ... the phase
    of this signal is periodically set to +90° or –90° (inverted),
    according to a pseudo-random pattern."
    - "This is (aka) Binary Phase Shift Keying (BPSK) at a given baud rate,
    with a maximum-length binary sequence generated by a Linear Feedback Shift Register (LFSR).
    ...the following combinations have been the most commonly used (recently):
    Baud rates of 11, 10, 1, 0.5, and 0.25 microsecond, corresponding to
    sequence lengths of 127, (127 and 511), (127, 255, and 1023), (127 and 255), 255
- Linear Frequency Modulation (LFM or “chirp”):
    - "The transmitter’s frequency is swept from (a center frequency of f0 + fofs to +/- df/2)
    over a time interval dt, where f0 = 8560 MHz, fofs is a small offset frequency,
    and df is the chirp bandwidth.  The frequency then snaps back instantaneously,
    but in a phase-continuous way, and the chirp is repeated."
    - "the following combinations have been used (recently):



-
Refer to the "Goldstone Solar System Radar (GSSR) Learning Manual",
downloaded from:
https://deepspace.jpl.nasa.gov/files/GSSR_learning_manual.pdf
"""
import numpy as np
import re
import argparse
import os
import json
from datetime import datetime, timezone
import matplotlib.pyplot as plt

from play.m_seq_gen import MSeqGeneratorLSFR

GOLDSTONE_BIT_PERIOD_SEC = 1E-6 # Duration of a single bit in Goldstone transmission

def simulate_goldstone_radar(fs, fc, duration, fofs=0.0 ):

    mseq_n = 1023  # Change this to 127, 255, 511, or 1023
    mseq_generator = MSeqGeneratorLSFR(mseq_n)
    modulating_code = np.fromiter(mseq_generator.generate(mseq_n), int)
    code_length = len(modulating_code)
    print(f"Sequence for n={mseq_n}: {code_length}")
    assert mseq_n == code_length

    T_bit = GOLDSTONE_BIT_PERIOD_SEC   # Duration of each code bit in seconds (1 µs for Goldstone), equiv to 1 Mbps

    # Calculate the number of samples per bit based on T_bit
    samples_per_bit = int(T_bit * fs)
    print(f"samples_per_bit: {samples_per_bit}")

    # Total duration of the signal
    total_samples = duration * fs
    total_bits_max = total_samples / samples_per_bit
    code_repeats = int(np.ceil(total_bits_max / code_length))
    total_samples = code_repeats * code_length * samples_per_bit
    print(f"code_repeats: {code_repeats} total_samples: {total_samples}")

    # Time vector for the entire transmission duration
    t = np.arange(0, total_samples) / fs
    modulating_sequence = np.repeat(modulating_code, samples_per_bit)
    print(f"modulating_sequence shape: {modulating_sequence.shape}  {modulating_sequence}")

    # Generate the carrier signal
    carrier_signal = np.cos(2 * np.pi * fc * t)
    print(f"carrier_signal: {carrier_signal.shape}")
    # Generate the modulation signal based on the Barker code
    modulation_signal = np.tile(modulating_sequence, code_repeats)
    print(f"modulation_sig shape: {modulation_signal.shape} ")

    # Modulate the carrier signal with the Barker code
    radar_signal = carrier_signal * modulation_signal

    return radar_signal, modulation_signal, carrier_signal, t


def main():
    parser = argparse.ArgumentParser(description='Grab sosme GNSS data using a remote Pluto SDR over IP')
    parser.add_argument('--freq_center','-fc', dest='freq_center_hz',type=float, default=1420.4000E6,
                        help='Center (carrier) frequency to use (Hz)')
    parser.add_argument('--sampling_rate','-fs', dest='sampling_rate_hz',type=float, default=2E6,
                        help='Samping rate to use (Hz)')
    parser.add_argument("--out_path",dest='out_path',default='./',
                        help="Directory path to place output files" )
    parser.add_argument('--duration', '-d',  dest="duration_secs", type=float,
                        default=10*13*GOLDSTONE_BIT_PERIOD_SEC,
                        help='Duration to generate, in seconds')

    args = parser.parse_args()
    out_path = args.out_path
    freq_center_hz = args.freq_center_hz
    sampling_rate_hz = args.sampling_rate_hz
    duration_secs = args.duration_secs

    if not os.path.isdir(out_path):
        print(f"out_path {out_path} does not exist")
        return -1


    radar_signal, modulation_signal, carrier_signal, times \
        = simulate_goldstone_radar(sampling_rate_hz, freq_center_hz, duration_secs)
    print(f"times: {times} signal: {radar_signal}")

    subplot_rows = 3
    subplot_row_idx = 0
    fig, axs = plt.subplots(subplot_rows, 1,  sharex=True, figsize=(12, 8))
    fig.suptitle("Goldstone Simulation")
    fig.subplots_adjust(hspace=0) # remove vspace between plots
    plt.xlabel("Time (sec)")

    plt.subplot(subplot_rows, 1, (subplot_row_idx:=subplot_row_idx+1))
    plt.plot(times, carrier_signal, color='g')
    plt.grid(True)
    plt.ylabel("Carrier")

    plt.subplot(subplot_rows, 1, (subplot_row_idx:=subplot_row_idx+1))
    plt.plot(times, modulation_signal, color='g')
    plt.grid(True)
    plt.ylabel("Modulation")

    plt.subplot(subplot_rows, 1, (subplot_row_idx:=subplot_row_idx+1))
    plt.plot(times, radar_signal, color='g')
    plt.grid(True)
    plt.ylabel("RF")

    plt.show()


if __name__ == "__main__":
    main()